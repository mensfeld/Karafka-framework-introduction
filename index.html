<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Karafka – Ruby framework for building Kafka message based applications</title>

    <meta name="description" content="Karafka - Ruby and Kafka powers combined">
    <meta name="author" content="Maciej Mensfeld">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/white.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <h2>Karafka – Ruby framework for building Kafka message based applications</h2>
          <img src="img/karafka-04.png" style="background: none; border: none; box-shadow: 0 0 0 0 #fff;"/>
          <p>
            <small>
              <a href="http://mensfeld.pl">Maciej Mensfeld</a> <br/>
              twitter: <a href="http://twitter.com/maciejmensfeld">@maciejmensfeld</a> </br>
              www: <a href="http://mensfeld.pl">mensfeld.pl</a> <br/>
              e-mail: <a href="mailto:maciej@mensfeld.pl">maciej@mensfeld.pl</a>
            </small>
          </p>
        </section>

        <section>
          <h4>A bit about me</h4>

          <ul>
          <li>I'm from Poland (Europe)</li>
          <li>9 years of commercial exp in IT</li>
          <li>7 years with Ruby and Rails</li>
          <li>I find Ruby quite useful</li>
          <li>I love open-source</li>
          <li>Interested in quality-assurance automation tools</li>
          <li>Running a blog mostly about Ruby related stuff</li>
          </ul>
        </section>

        <section>
          <h4>Please notify me if...</h4>

          <ul>
          <li>I speak 2 fast</li>
          <li>I should repeat something</li>
          <li>I should explain something better</li>
          <li>You have any questions</li>
          </ul>
        </section>

        <section>
          <h4>What is Apache Kafka?</h4>

          <ul>
            <li>Kafka is a high-throughput distributed messaging system</li>
            <li>Kafka is designed to allow a single cluster to serve as the central data backbone for a large organization</li>
            <li>It can be elastically and transparently expanded without downtime</li>
            <li>It provides broadcasting to many applications</li>
            <li>Allows to build systems that are event based</li>
          </ul>
        </section>

        <section>
          <h4>Who uses Apache Kafka?</h4>

          <ul style="padding-right: 10%;">
            <li>Linkedin</li>
            <li>Yahoo</li>
            <li>Twitter</li>
            <li>Netflix</li>
            <li>Square</li>
            <li>Spotify</li>
            <li>Pinterest</li>
            <li>Uber</li>
          </ul>

          <ul>
            <li>Tumblr</li>
            <li>Cisco</li>
            <li>Foursquare</li>
            <li>Shopify</li>
            <li>Oracle</li>
            <li>Urban Airship</li>
            <li>OVH</li>
            <li>And many more...</li>
          </ul>
        </section>

        <section>
          <h4>What is Karafka?</h4>

          <ul>
            <li>Karafka = Kafka + Ruby => KaR(uby)afka</li>
            <li>It is a microframework </li>
            <li>It was designed to simplify Kafka based applications development</li>
            <li>It allows developers to build "Rails like" apps that consume and produce messages</li>
          </ul>
        </section>

        <section>
          <h4>Why we developed Karafka?</h4>

          <ul>
            <li>We've needed a tool that would allow us to build applications faster</li>
            <li>We've needed a tool that would allow us to process faster</li>
            <li>We've needed a tool that would allow us to handle events and messages from many sources and process them the same way</li>
            <li>Because single message can be automatically delivered to many Karafka applications</li>
          </ul>
        </section>

        <section>
          <h4>Why even bother with messaging when there is HTTP and REST?</h4>

          <ul>
            <li>HTTP does not provide broadcasting</li>
            <li>We often need to trigger many actions based on a single event</li>
            <li>We don't want to maintain internal API clients</li>
            <li>With a message broker you can replace microservices transparently</li>
            <li>You can obtain better microservices isolation</li>
            <li>Because you can create new microservices that use multiple different events from many sources</li>
          </ul>
        </section>

        <section>
          <h4>It really is about messaging</h4>
        </section>

        <section>
          <h4>Real life is asynchronous</h4>
        </section>

        <section>
          <h4>Microservices without broadcasting</h4>

          <p>
            Without a broker you need to add code to both ends of your SOA system
          </p>

          <img src="img/karafka1.png" style="max-width: 35%"/>
        </section>

        <section>
          <h4>Microservices with broadcasting</h4>

          <p>
          With a broker all you need to know is topic on which you want to listen and a message format
          </p>

          <img src="img/karafka2.png" style="max-width: 35%"/>
        </section>

        <section>
          <h4>Karafka uses goods that are already well known</h4>

          <ul>
            <li>Ruby-Kafka</li>
            <li>Celluloid to introduce sockets clustering inside threads</li>
            <li>Sidekiq to support background data processing</li>
            <li>Rails app structure concept for bigger apps</li>
            <li>Sinatra app structure concept for small apps</li>
          </ul>
        </section>

        <section>
          <h4>Karafka ecosystem</h4>

          <p>
            Each part can be used independently
          </p>

          <ul>
            <li>Karafka Framework - Engine to process incoming messages</li>
            <li>WaterDrop - Ruby-Kafka based library for outgoing messages</li>
            <li>Worker Glass - Worker wrapper that provides optional timeout and after failure (reentrancy)</li>
          </ul>
        </section>

        <section>
          <h4>Karafka framework components</h4>

          <p>
            Apart of the implementation details, Karafka is combined from few logical parts:
          </p>

          <ul>
            <li>Messages Consumer (Karafka::Connection::Consumer)</li>
            <li>Router (Karafka::Routing::Router)</li>
            <li>Base Controller (Karafka::BaseController)</li>
            <li>Base Worker (Karafka::BaseWorker)</li>
            <li>CLI (Karafka::Cli)</li>
          </ul>
        </section>

        <section>
          <h4>Karafka framework components</h4>

          <img src="img/karafka3.png" style="max-width: 45%"/>
        </section>

        <section>
          <h4>How can I start using it?</h4>

<pre><code data-trim>
# Gemfile
source 'https://rubygems.org'

gem 'karafka', github: 'karafka/karafka'
</code></pre>

<pre><code data-trim>
bundle install
bundle exec karafka install
</code></pre>

          <p>
            Then open app.rb and update configuration settings
          </p>

          <p>
          All the configutation options are described here:<br/><a href="https://github.com/karafka/karafka">github.com/karafka/karafka</a>
          </p>

        </section>

        <section>
          <h4>Karafka conventions and features</h4>
        </section>

        <section>
          <h4>Karafka conventions and features</h4>

          <p>
            Karafka has a routing engine similar to the Rails one (just much smaller)
          </p>


<pre><code data-trim>
App.routes.draw do
  topic :incoming_messages do
    group :composed_application
    controller Videos::DetailsController
    worker Workers::DetailsWorker
    parser Parsers::BinaryToJson
    interchanger Interchangers::Binary
  end

  # If you work with JSON data, only controller is required
  topic :new_videos do
    controller Videos::NewVideosController
  end
end
</code></pre>

        </section>

        <section>
          <h4>Karafka conventions and features</h4>

<pre><code data-trim>
NewVideosController  #=> NewVideosWorker
Users::PaymentsController #=> Users::PaymentsWorker
</code></pre>

          <p>
            By default Karafka builds a worker class per controller based on a controller name. This will allow you to prioritize (if needed) Sidekiq workers
          </p>


        </section>






        <section>
          <h4>Karafka conventions and features</h4>

          <p>
            You can overwrite all of the default behaviours
          </p>

<pre><code data-trim>
  # If you work with JSON data, only controller is required
  topic :new_videos do
    controller Videos::NewVideosController
    # Instead of a default Videos::NewVideosWorker
    worker Videos::DifferentWorker
  end
end
</code></pre>
        </section>


        <section>
          <h4>Karafka conventions and features</h4>

          <p>
            Karafka controllers are simple. All you need is a #perform method that will be executed asynchronously in response to an incoming message
          </p>
<pre><code data-trim>
class CreateVideosController < Karafka::BaseController
  def perform
    Video.create!(params[:video])
  end
end
</code></pre>
        </section>

        <section>
          <h4>Karafka conventions and features</h4>

          <p>
            #before_enqueue filter that acts in a similar way to Rails #before_action
          </p>
<pre><code data-trim>
class CreateVideosController < Karafka::BaseController
  before_enqueue -> {
    # Reject old incoming messages
    # When before_enqueue throws false,
    # task won't be send to Sidekiq
    throw(:abort) if params[:sent_at] < 1.minute.ago
  }
end
</code></pre>

          <p>
            It can be used to provide first layer data filtering. If it returns false, Sidekiq task won't be scheduled
          </p>
        </section>

        <section>
          <h4>Karafka conventions and features</h4>

There are also few usefull CLI commands available:

<pre><code data-trim>
bundle exec karafka [COMMAND]

console # Start the Karafka console (short-cut alias: "c")
flow    # Print application data flow (incoming => outgoing)
help    # Describe available commands or one specific command
info    # Print configuration details and other options
install # Install all required things for Karafka application
routes  # Print out all defined routes in alphabetical order
server  # Start the Karafka server (short-cut alias: "s")
worker  # Start the Karafka Sidekiq worker (short-cut alias: "w")
</pre></code>
        </section>

        <section>
          <h4>Karafka performance</h4>

          <ul>
            <li>Is strongly dependent on what you do in your code</li>
            <li>Redis performance (for Sidekiq) is a factor as well</li>
            <li>Message size is a factor</li>
            <li>Single process can handle around 30 000 messages/sec</li>
            <li>Less than a ms to send a message with the slowest (secure) mode (Kafka request.required.acks -1) </li>
            <li>Less than 1/10 of a ms to send a message with in the 0 mode (Kafka request.required.acks 0) </li>
          </ul>
        </section>

        <section>
          <h4>Karafka framework scalability</h4>

          <p>
            Each scaling strategy targets a different problem
          </p>

          <p>
            Scaling strategies can be combined
          </p>

          <p>
            Following strategies are available:
          </p>

          <ul>
            <li>Scaling using multiple Karafka threads</li>
            <li>Scaling using Kafka partitions</li>
            <li>Scaling using Karafka clusterization (in progress)</li>
          </ul>
        </section>

        <section>
          <h4>Scaling using multiple threads</h4>

          <ul>
            <li>Good when you have multiple topics that are not 100% utilized</li>
            <li>Good when you want to provide paralleism but still have a single process running</li>
            <li>Generally the easiest way to have multiple controllers listening at the same time</li>
          </ul>
        </section>

        <section>
          <h4>Scaling using multiple threads</h4>

          <img src="img/karafka4.png" style="max-width: 50%"/>

        </section>

        <section>
          <h4>Scaling using Kafka partitions</h4>

          <ul>
            <li>Topic partition is the unit of parallelism in Kafka</li>
            <li>Partitions are an answer to heavy duty topics</li>
            <li>Karafka processes automatically rebalances between available partitions</li>
            <li>Karafka requires topics partitioning when you want to handle more than 30 000 messages per second per topic</li>
          </ul>
        </section>

        <section>
          <h4>Scaling using Kafka partitions</h4>

          <img src="img/partitions.png" style="max-width: 70%"/>
        </section>

        <section>
          <h4>Scaling using Karafka processes clustering</h4>

          <ul>
            <li>Single Karafka process can handle up to 30 000 messages per second (total)</li>
            <li>It means that the bigger your application is, the slower it gets (per controller)</li>
            <li>Thanks to process clustering, each Karafka process will listen only to a selected part of topics</li>
            <li>That way with a 10 process cluster, we can increase throughput to more than 300 000 messages per second</li>
          </ul>
        </section>

        <section>
          <h4>Scaling using Karafka processes clustering</h4>

          <img src="img/cluster2.png" style="max-width: 70%"/>
        </section>

        <section>
          <h4>I want to integrate it with my Rails/Sinatra app</h4>

          <ul>
            <li>The best approach is to start generating messages from your current applications via
                <a href="https://github.com/karafka/waterdrop">WaterDrop</a>
            </li>
            <li>With WaterDrop you can tell your Karafka apps what your other Ruby components are doing</li>
          </ul>

<pre><code data-trim>
def create
  video = Video.create!(params[:video])
  WaterDrop::Message.new(:video_created, video.to_json).send!
  respond_with video
end
</pre></code>

          <ul>
            <li>Once you start sending messages, you can extract functionalities and responsibilities and move them to Karafka based applications</li>
          </ul>
        </section>

        <section>
          <h2>WANT TO CONTRIBUTE?</h2>

          <p>
            <a href="https://github.com/karafka">github.com/karafka</a>
          </p>


          <p>
            <img src="img/github.png" style="background: none; border: none; box-shadow: 0 0 0 0 #fff; margin: 0; padding: 0;"/>
          </p>

          <ul>
            <li>The more people star it, the more people use it</li>
            <li>The more people use it, the more people star it</li>
            <li>There are many issues you can help us fix</li>
            <li>We use Code Climate and Travis with many QA tools to maintain the quality</li>
          </ul>
        </section>


        <section>
          <h2>READ MORE</h2>

          <ul>
            <li><a href="https://github.com/karafka/karafka">github.com/karafka/karafka</a></li>
            <li><a href="https://github.com/karafka">github.com/karafka</a></li>
            <li><a href="http://dev.mensfeld.pl/tag/karafka">dev.mensfeld.pl/tag/karafka</a></li>
            <li><a href="http://kafka.apache.org/">kafka.apache.org</a></li>
            <li><a href="https://zookeeper.apache.org">zookeeper.apache.org</a></li>
          </ul>
        </section>

        <section>
          <h1>THE END - Q &amp; A</h1>

          <ul>
            <li><a href="https://github.com/karafka">github.com/karafka</a></li>
            <li><a href="mailto:maciej@mensfeld.pl">maciej@mensfeld.pl</a></li>
            <li><a href="http://twitter.com/maciejmensfeld">@maciejmensfeld</a></li>
            <li><a href="http://mensfeld.pl">mensfeld.pl</a></li>
          </ul>
        </section>

      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });

    </script>

  </body>
</html>
