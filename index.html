<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Karafka – Ruby framework for building Kafka message based applications</title>

    <meta name="description" content="Karafka - Ruby and Kafka powers combined">
    <meta name="author" content="Maciej Mensfeld">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/white.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <h2>Karafka – Ruby framework for building Kafka message based applications</h2>
          <img src="img/kafka.jpg" style="background: none; border: none; box-shadow: 0 0 0 0 #fff;"/>
          <img src="img/rubylogo.gif" style="background: none; border: none; box-shadow: 0 0 0 0 #fff;"/>
          <p>
            <small>
              <a href="http://mensfeld.pl">Maciej Mensfeld</a> /
              <a href="http://twitter.com/maciejmensfeld">@maciejmensfeld</a> /
              <a href="http://mensfeld.pl">mensfeld.pl</a>
            </small>
          </p>
        </section>

        <section>
          <h4>What is Apache Kafka?</h4>

          <ul>
            <li>Kafka is a high-throughput distributed messaging system</li>
            <li>Kafka is designed to allow a single cluster to serve as the central data backbone for a large organization</li>
            <li>It can be elastically and transparently expanded without downtime</li>
            <li>It provides broadcasting to many applications</li>
            <li>Allows to build systems that are event based</li>
          </ul>
        </section>

        <section>
          <h4>Who uses Apache Kafka?</h4>

          <ul style="padding-right: 10%;">
            <li>Linkedin</li>
            <li>Yahoo</li>
            <li>Twitter</li>
            <li>Netflix</li>
            <li>Square</li>
            <li>Spotify</li>
            <li>Pinterest</li>
            <li>Uber</li>
          </ul>

          <ul>
            <li>Tumblr</li>
            <li>Cisco</li>
            <li>Foursquare</li>
            <li>Shopify</li>
            <li>Oracle</li>
            <li>Urban Airship</li>
            <li>OVH</li>
            <li>And many more...</li>
          </ul>
        </section>

        <section>
          <h4>What is Karafka?</h4>

          <ul>
            <li>Karafka = Kafka + Ruby => KaR(uby)afka</li>
            <li>It is a microframework </li>
            <li>It was designed to simplify Kafka based applications development</li>
            <li>It allows developers to build "Rails like" apps that consume and produce messages</li>
          </ul>
        </section>

        <section>
          <h4>Why we developed Karafka?</h4>

          <ul>
            <li>Because Ruby is good</li>
            <li>Because Kafka is good </li>
            <li>We've needed tool that would allow us to build applications faster</li>
            <li>We've needed tool that would allow us to process faster</li>
            <li>We've needed tool that would allow us to handle events and messages from many sources and process them the same way</li>
          </ul>
        </section>

        <section>
          <h4>Why even bother with messaging when there is HTTP and REST?</h4>

          <ul>
            <li>Because HTTP does not provide broadcasting</li>
            <li>Because we often need to trigger many actions based on a single event</li>
            <li>Because we don't need to maintain internal API clients</li>
            <li>Because with a message broker you can replace microservices transparently</li>
            <li>Because you can obtain better microservices isolation</li>
            <li>Because you can create new microservices that use multiple different events from many sources</li>
          </ul>
        </section>

        <section>
          <h4>It really is about messaging</h4>
        </section>

        <section>
          <h4>Real life is asynchronous</h4>
        </section>

        <section>
          <h4>Microservices without broadcasting</h4>

          <p>
            Without a broker you need to add code to both ends of your SOA system
          </p>

          <img src="img/karafka1.png" style="max-width: 35%"/>
        </section>

        <section>
          <h4>Microservices with broadcasting</h4>

          <p>
          With broker all you need to know is topic on which you want to listen
          </p>

          <img src="img/karafka2.png" style="max-width: 35%"/>
        </section>

        <section>
          <h4>Karafka uses goods that are already existing</h4>

          <ul>
            <li>Most popular Ruby Kafka client: Poseidon</li>
            <li>Poseidon Cluster gem for topic partition distribution</li>
            <li>Celluloid to introduce sockets clustering inside threads</li>
            <li>Sidekiq to support background data processing</li>
            <li>Rails app structure (app/ config/ lib/) for bigger apps</li>
            <li>Sinatra app structure for small apps (even as a single file)</li>
          </ul>
        </section>

        <section>
          <h4>Karafka ecosystem</h4>

          <p>
            Each part can be used independently
          </p>

          <ul>
            <li>Karafka Framework - Engine to process incoming messages</li>
            <li>WaterDrop - Poseidon based library for outgoing messages</li>
            <li>Sidekiq Glass - Sidekiq worker wrapper that provides optional timeout and after failure (reentrancy)</li>
          </ul>
        </section>

        <section>
          <h4>Karafka framework components</h4>

          <p>
            Apart of the implementation details, Karafka is combined from few logical parts:
          </p>

          <ul>
            <li>Messages Consumer (Karafka::Connection::Consumer)</li>
            <li>Router (Karafka::Routing::Router)</li>
            <li>Base Controller (Karafka::BaseController)</li>
            <li>Base Worker (Karafka::BaseWorker)</li>
          </ul>
        </section>

        <section>
          <h4>Karafka framework components</h4>

          <img src="img/karafka3.png" style="max-width: 45%"/>
        </section>

        <section>
          <h4>Karafka framework scalability</h4>

          <p>
            Each scaling strategy targets a different problem
          </p>

          <p>
            Scaling strategies can be combined
          </p>

          <p>
            Following strategies are available:
          </p>

          <ul>
            <li>Scaling using multiple Karafka threads</li>
            <li>Scaling using Kafka partitions</li>
            <li>Scaling using Karafka clusterization</li>
          </ul>
        </section>

        <section>
          <h4>Scaling using multiple threads</h4>

          <ul>
            <li>Good when you have multiple topics that are not 100% utilized</li>
            <li>Good when you want to provide paralleism but still have a single process running</li>
            <li>Generally the easiest way to have multiple controllers listening at the same time</li>
          </ul>
        </section>

        <section>
          <h4>Scaling using multiple threads</h4>

          <img src="img/karafka4.png" style="max-width: 50%"/>

        </section>

        <section>
          <h4>Scaling using Kafka partitions</h4>

          <ul>
            <li>Topic partition is the unit of parallelism in Kafka</li>
            <li>Partitions are an answer to heavy duty topics</li>
            <li>Karafka processes automatically rebalance between available partitions</li>
            <li>Karafka requires topics partitioning when you want to handle more than 30 000 messages per second per topic</li>
          </ul>
        </section>

        <section>
          <h4>Scaling using Kafka partitions</h4>

          <img src="img/partitions.png" style="max-width: 70%"/>
        </section>

        <section>
          <h4>Scaling using Karafka process cluster</h4>

          <ul>
            <li>Single Karafka process can handle up to 30 000 messages per second (total)</li>
            <li>It measn that the bigger your application is the slower it gets (per controller)</li>
            <li>Thanks to process clustering, each Karafka process will listen only to a selected part of topics</li>
            <li>That way with a 10 process cluster, we can increase throughput to more than 300 000 messages per second</li>
          </ul>
        </section>

        <section>
          <h4>Scaling using Karafka process cluster</h4>


          <img src="img/cluster2.png" style="max-width: 70%"/>
        </section>

        <section>
          <h4>How can I start using it?</h4>

<pre><code data-trim>
# Gemfile
source 'https://rubygems.org'

gem 'karafka', github: 'karafka/karafka'
</code></pre>

<pre><code data-trim>
# rakefile.rb
ENV['KARAFKA_ENV'] ||= 'development'

Bundler.require(:default, ENV['KARAFKA_ENV'])
</code></pre>

<pre><code data-trim>
bundle install
bundle exec rake karafka:install
</code></pre>

          <p>
            Then open app.rb and update configuration settings
          </p>

          <p>
          All the configutation options are described here:<br/><a href="https://github.com/karafka/karafka">github.com/karafka/karafka</a>
          </p>

        </section>

        <section>
          <h4>Karafka conventions and features</h4>
        </section>

        <section>
          <h4>Karafka conventions and features</h4>

          <p>
            Karafka maps controllers names directly to topics names, so you can easily build you applications based on topics naming conventions
          </p>


<pre><code data-trim>
NewVideosController.topic #=> :new_videos
NewVideosController.worker #=> NewVideosWorker
Users::PaymentsController.topic #=> :users_payments
Users::PaymentsController.worker #=> Users::PaymentsWorker
</code></pre>

          <p>
            By default Karafka builds a worker class per controller based on a controller name. This will allow you to prioritize (if needed) some of the Sidekiq workers (or spin up separate workers for given queues)
          </p>

        </section>

        <section>
          <h4>Karafka conventions and features</h4>

          <p>
            Of course you can overwrite all of the default behaviours
          </p>

<pre><code data-trim>
class CreateVideosController < Karafka::BaseController
  self.topic = :super_topic_name
  self.worker = MyDifferentWorker

  def perform; end
end
</code></pre>
        </section>

        <section>
          <h4>Karafka conventions and features</h4>

          <p>
            Karafka controllers are simple. All you need is a #perform method that will be executed asynchronously in response to an incoming message
          </p>
<pre><code data-trim>
class CreateVideosController < Karafka::BaseController
  def perform
    Video.create!(params[:video])
  end
end
</code></pre>
        </section>

        <section>
          <h4>Karafka conventions and features</h4>

          <p>
            #before_enqueue filter that acts in a similar way to Rails #before_action
          </p>
<pre><code data-trim>
class CreateVideosController < Karafka::BaseController
  before_enqueue -> {
    # Reject old incoming messages
    # When before_enqueue returns false,
    # task won't be send to Sidekiq
    return false if params[:sent_at] < 1.minute.ago
  }
end
</code></pre>

          <p>
            It can be used to provide first layer data filtering
          </p>
        </section>

        <section>
          <h4>Karafka conventions and features</h4>

There are also few usefull rake tasks available:

<pre><code data-trim>
bundle exec rake -T
rake kafka:topics     # Lists all the topics available on a Kafka
rake karafka:install  # Creates whole minimal app structure
rake karafka:run      # Runs a single Karafka processing instance
rake karafka:sidekiq  # Runs a single Sidekiq worker for Karafka
</pre></code>
        </section>

        <section>
          <h1>THE END - Q &amp; A</h1>
        </section>

      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });

    </script>

  </body>
</html>
